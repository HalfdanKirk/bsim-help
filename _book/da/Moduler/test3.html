
<!DOCTYPE HTML>
<html lang="da" >
    <head>
        <meta charset="UTF-8">
        <title>Test3 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-language-picker/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles.css">
        
    

        

    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="test4.html" />
    
    
    <link rel="prev" href="../Diverse/test2.html" />
    

<script>window.MathJax = { tex: { inlineMath: [[\"\\\(\",\"\\\)\"],[\"$\",\"$\"]], displayMath: [[\"\\\[\",\"\\\]\"],[\"$$\",\"$$\"]], packages: {'[+]': ['ams','textmacros']}, processEscapes: true }, options: { skipHtmlTags: [\"script\",\"noscript\",\"style\",\"textarea\",\"pre\",\"code\"] } };</script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<script>(function(){function cleanNBSP(root){var t=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);var n;while((n=t.nextNode())){if(n.nodeValue.indexOf('\u00A0')!==-1){n.nodeValue=n.nodeValue.replace(/\u00A0/g,' ');}}}function ts(){if(window.MathJax&&window.MathJax.typesetPromise){cleanNBSP(document.body);return window.MathJax.typesetPromise();}}function bind(){if(window.gitbook&&gitbook.events){gitbook.events.bind('page.change',ts);}document.addEventListener('DOMContentLoaded',ts);}if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',bind);}else{bind();}})();</script>
<script>document.addEventListener('DOMContentLoaded',function(){var l=document.createElement('link');l.rel='stylesheet';l.href=new URL('styles.css', document.baseURI).toString();document.head.appendChild(l);});</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">DIVERSE</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Diverse/test1.html">
            
                <a href="../Diverse/test1.html">
            
                    
                    Test1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../Diverse/test2.html">
            
                <a href="../Diverse/test2.html">
            
                    
                    Test2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="20_04_Fugtbalancen_for_en_zone.html">
            
                <a href="20_04_Fugtbalancen_for_en_zone.html">
            
                    
                    Test_Anders
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../EFFECTIVEMOISTURE.html">
            
                <a href="../EFFECTIVEMOISTURE.html">
            
                    
                    TEST
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1.1" data-path="../Diverse/test2.html">
            
                <a href="../Diverse/test2.html">
            
                    
                    TEST3
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Moduler</li>
        
        
    
        <li class="chapter active" data-level="2.1" data-path="test3.html">
            
                <a href="test3.html">
            
                    
                    Test3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="test4.html">
            
                <a href="test4.html">
            
                    
                    Test4
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">06BSim_Programstruktur</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../06Bsim_Programstruktur/06_01_Strukturen_i_BSim.html">
            
                <a href="../06Bsim_Programstruktur/06_01_Strukturen_i_BSim.html">
            
                    
                    Strukturen i BSim
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../06Bsim_Programstruktur/06_02_About_BSim.html">
            
                <a href="../06Bsim_Programstruktur/06_02_About_BSim.html">
            
                    
                    About BSim
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../06Bsim_Programstruktur/06_03_Operationer_med_musen_i_SimView.html">
            
                <a href="../06Bsim_Programstruktur/06_03_Operationer_med_musen_i_SimView.html">
            
                    
                    Operationer med musen
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="../06Bsim_Programstruktur/06_04_Programmenuer_i_BSim.html">
            
                <a href="../06Bsim_Programstruktur/06_04_Programmenuer_i_BSim.html">
            
                    
                    Programmenuer i BSim
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="../06Bsim_Programstruktur/06_05_SimView_Værktøjsbjælken.html">
            
                <a href="../06Bsim_Programstruktur/06_05_SimView_Værktøjsbjælken.html">
            
                    
                    SimView Værktøjsbjælken
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="../06Bsim_Programstruktur/06_06_SimView_Menu.html">
            
                <a href="../06Bsim_Programstruktur/06_06_SimView_Menu.html">
            
                    
                    SimView Menu
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="../06Bsim_Programstruktur/06_07_SimView_Udskrift_af_model.html">
            
                <a href="../06Bsim_Programstruktur/06_07_SimView_Udskrift_af_model.html">
            
                    
                    Simview - Udskrift af model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.8" data-path="../06Bsim_Programstruktur/06_08_Fejlmeddelelser.html">
            
                <a href="../06Bsim_Programstruktur/06_08_Fejlmeddelelser.html">
            
                    
                    Fejlmeddelelser
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.9" data-path="../06Bsim_Programstruktur/06_09_SimView_Oprette_en_bygning.html">
            
                <a href="../06Bsim_Programstruktur/06_09_SimView_Oprette_en_bygning.html">
            
                    
                    Simview - Oprette en bygning
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Test3</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <figure id="center_img">
  <img src="assets/IKtjek_logo.png" alt="Test"></img>
  <figcaption>Test</figcaption>
</figure>


<h1 id="simlight-teori">SimLight teori</h1>
<p><em>Troels Ravn</em></p>
<h3 id="contents"><strong>Contents</strong></h3>
<ul>
<li><p>Models for the environment</p>
<ul>
<li><p>Uniformly overcast sky</p>
</li>
<li><p>CIE-overcast sky</p>
</li>
<li><p>CIE-clear sky</p>
</li>
</ul>
</li>
<li><p>Calculation of the direct illumination</p>
</li>
<li><p>Calculation of the externally reflected illumination</p>
</li>
<li><p>Calculation of the internally reflected illumination</p>
<ul>
<li><p>Surface subdivision</p>
</li>
<li><p>Calculation of initial illumination</p>
</li>
<li><p>Shape-factor calculation</p>
</li>
<li><p>Inter-reflection calculation</p>
</li>
</ul>
</li>
<li><p>Validation</p>
</li>
<li><p>Default material properties</p>
</li>
<li><p>Limitations</p>
</li>
<li><p>References</p>
</li>
</ul>
<p>The SimLight application is a tool which is available as part of the BSim-package. The modeling of the spaces are performed by SimView and the accessibility of the modeling of the daylighting specifics in SimLight concerns mainly the modeling of the environmental characteristics and the definition of reference points. The user interface for the SimLight application is a dialog box containing all information concerning single point daylighting contribution calculations. There are two additional underlying dialog boxes, which come in to play when multiple-point daylighting calculations are to be carried out. One dialog box is used to define the grid of calculation points, the other to present the results of the multiple-point calculation.</p>
<p>The general approach to the daylighting calculations in SimLight is of a Finite Element Method (FEM). As FEM-based radiation calculation can require excessive computational time, functions permitting dynamical altering of the inhomogeneous finite element grid have been implemented. This is of particular significance when calculating the internally reflected illumination.</p>
<h3 id="models-for-the-environment"><strong>Models for the environment</strong></h3>
<p>The outdoors terrain is modeled as a Site object. BSim facilitate modeling of outdoors obstructions, but SimLight does not take it into account yet.</p>
<p>The sky can be defined according to three different models, all taken from (1), which are described below.</p>
<p><strong>Uniformly overcast sky</strong></p>
<p>The model of the uniformly overcast sky is based on the assumption that the sky is a perfect diffuser and has a uniform luminance at all points on the celestial dome. The relation between the illumination on the horizontal plane (E<sub>H</sub>) and the zenith luminance (L<sub>Z</sub>) is given by:</p>
<p><span class="mathjax-block">\[
E_H = \pi \cdot L_Z \tag{1}
\]</span></p>
<p><strong>CIE-overcast sky</strong></p>
<p>The luminance of the CIE-overcast sky follows the Moon and Spencer distribution. The luminance at the horizon is one third of the zenith luminance. The relation between the luminance at angle θ (L<sub>θ</sub>) and the zenith luminance (L<sub>Z</sub>, Z=90°) is given by:</p>
<p><span class="mathjax-block">\[
L_{\gamma_s} = L_Z \left( \frac{1 + 2 \sin \gamma_s}{3} \right)&nbsp; \tag{2}
\]</span></p>
<p>The relation between the illumination on the horizontal plane (E<sub>H</sub>) and the zenith luminance (L<sub>Z</sub>) is given as:</p>
<p><span class="mathjax-block">\[
E_H = \frac{7 \pi}{9} \cdot L_Z \tag{3}
\]</span></p>
<p><strong>CIE-clear sky</strong></p>
<p>The luminance of the CIE-clear sky is described by Kittlers formula. It takes into consideration the atmospherically diffusion of the sunlight when the sky is clear, but does not include the special conditions of luminance near and on the solar disc. The relation between the luminance at a point on the celestial dome (L<sub>θ,α</sub>) and the zenith luminance (L<sub>Z</sub>, Z=90°) is:</p>
<p><span class="mathjax-block">\[
L_{\theta, \alpha} = \frac{1 - e^{\frac{-32}{\cos \varepsilon}}}{0.274}   
\left( \frac{0.91 + 10 \cdot e^{-3 \psi} + 0.45 \cdot \cos^2 \psi} {0.91 + 10 \cdot e^{-3 Z_s} + 0.45 \cdot \cos^2 \gamma_s} \right) L_z \tag{4}
\]</span></p>
<p>where:<br></br>ψ     is the angle between the sun and the point in question,<br></br>ε      is the angle between zenith and the point in question,<br></br>Z<sub>s</sub>   is the angle between zenith and the sun and<br></br>γ<sub>s</sub>    is the sun height, all measured in radians.</p>
<p>The zenith luminance is approximated by the formula:</p>
<p><span class="mathjax-block">\[
L_Z = 72 \cdot H&nbsp;\tag{5}
\]</span></p>
<p>and the illumination on a horizontal plane is approximated by the empirical formula:</p>
<p><span class="mathjax-block">\[
E_H = 1100 + 15500 \cdot \sqrt{\sin H}&nbsp;\tag{6}
\]</span></p>
<p>where H is the sun height measured in degrees.</p>
<h3 id="calculation-of-the-direct-illumination"><strong>Calculation of the direct illumination</strong></h3>
<p>The calculation of the direct illumination at the reference point is based on the theory presented in (2). The basic formula used to calculate the illumination contribution from a light source is:</p>
<p><span class="mathjax-block">\[
E_R =&nbsp;\int\limits_{\text{A = area}} \frac{L_{dA} \sin \theta \cos \theta}{R^2} \, dA \tag{7}
\]</span></p>
<p>where<br></br>L<sub>dA</sub> is the luminance at dA,<br></br>θ is the angle between the angle of incidence and the perpendicular at the reference point,<br></br>R is the distance between the reference point dA.</p>
<p>Numerical integration can be applied if and when dA is of such size and geometry that the values of θ and L<sub>dA</sub> can be assumed constant throughout dA. In SimLight, this quality is obtained in the following manner: The windows are subdivided in to triangular elements. The subdivision is handled in such a way that all subdivisions are carried out by splitting the longest side in the triangle at the midpoint. This ensures that the geometrical moment of inertia of the triangles is minimized and thus the geometrical requirements on dA are met. To ensure that the variation of θ and L<sub>dA</sub> are "small" throughout the triangular elements, the subdivision algorithm in SimLight compares the upper limit of the apparent area of the triangular elements, as seen from the reference point, to the area of a sphere which is centered at the reference point and which has a radius that is equal to the distance between the reference point and the center-point of the triangle in question. If the ratio between the two exceeds a certain value, the triangle is subdivided. In the present version, the ratio has been experimentally determined. The ratio between the maximum apparent area and the area of the sphere is set to 1/20, 1/32 and 1/44 for low, medium and high precision respectively.</p>
<p>When the window has been subdivided into triangular elements, the contribution to the illumination at the reference point from all elements whose center-points map to a point on the celestial dome are summed up.</p>
<p>If the window has not been defined with a specific type of window in SimView, the illumination of every triangle is set equal to the illumination of the point on the celestial dome, to which the triangle's center-point map. If the window has been defined with a type, the illumination of the triangle is multiplied with the transmittance of the glazing. In the present version of SimLight, only clear, double glazed windows can be handled. Therefore, all windows, which have been defined with a type, are treated as windows with this kind of glazing. The calculation of the transmittance of the glazing includes dependency on the angle of incidence in the cases where a window has been defined with a type. The algorithm is taken from the tsbi3 application, which was released by Danish Building Research Institute in 1993.</p>
<p>With the correction for reduced transmittance included, the sum of contributions from all triangular elements is given as the result for the direct illumination at the reference point.</p>
<p>The database in BSim includes information on the amount of framing material used for each type of window. In SimLight, the framing material is assumed to be uniformly distributed along the circumference of the window and with a width as defined in the database. Triangular elements whose center-points map to a point on the frame do not contribute to the direct or to the externally reflected illumination.</p>
<h3 id="calculation-of-the-externally-reflected-illumination"><strong>Calculation of the externally reflected illumination</strong></h3>
<p>The calculation of the externally reflected illumination takes place in the same step as the calculation of the direct illumination. The triangles whose center-points do not map to a point on the celestial dome, maps to either the outdoors terrain, the fins around the window (defined in SimView), the sides of the opening containing the window or the frame around the window glazing.</p>
<p>In case a center-point maps to the outdoors terrain, the illumination of the triangle is set to the site reflectance multiplied by the zenith luminance of the sky model. It can be argued that the zenith luminance should not be used for the estimate in other cases than for skies of uniform luminance, but that the average sky luminance should be used in stead. However, as the estimate of the reflectance of the outdoors terrain is very uncertain and as the externally reflected component rarely constitutes a significant fraction of the illumination at the reference point, the error introduced by basing the luminance on the zenith luminance is estimated to be insignificant.</p>
<p>In case a center-point maps to the fins around the window, the illumination of the triangle is set to the zenith luminance multiplied by the reflectance of the outer finish of the construction containing the window (defined in SimView or otherwise the default reflectance). Again it may be argued that the zenith luminance is not the correct basis for the calculation of the illumination on the fin. Indeed, in this case it would be better to carry out yet another calculation, namely to calculate the illumination falling upon the point on the fin where the triangle center-point maps. The significance of the consequences of the chosen approximation and the trade-off that will arise (increased computational time) when implementing the more correct method will be investigated in the future.</p>
<p>In case a center-point maps to the sides of the opening containing the window, the illumination of the triangle is calculated as in the case with the mapping to the fin. The same arguments as above apply.</p>
<p>As mentioned in the previous section, no contribution from the triangle in question is calculated in case a center-point maps to the frame around the window glazing.</p>
<h3 id="calculation-of-the-internally-reflected-illumination"><strong>Calculation of the internally reflected illumination</strong></h3>
<p>The calculation of the internally reflected illumination is the crucial part of the calculation process seen from a computational point of view. Calculation of this component requires knowledge about the luminance at every point on the interior surfaces of the space. The luminance is determined by the illumination on the interior surfaces. This illumination is also composed of direct, externally reflected and internally reflected illumination. The first step of the calculation of the internally reflected illumination at the reference point is therefore to calculate the illumination at all points on the interior surfaces and the inter-reflection between each one of these points. These calculations comprise the most time consuming steps of the entire process.</p>
<p>SimLight applies an FEM approach to model the inter-reflection in a space. First, all interior surfaces in the space are subdivided with triangular elements. Then, the direct and externally reflected illumination falling upon all surface elements are calculated and the shape factors between all elements which "see" each other are calculated. The reflectance of the surfaces, the illumination and the shape-factors are then utilized to set up a daylighting balance in the space. Once this balance has been determined, the internally reflected illumination at the reference point is calculated. A step-by-step description of the processes is found below.</p>
<p>Two steps in particular requires considerable computational time:</p>
<ul>
<li><p>(Repeated) subdivision of the interior surfaces and calculation of initial illumination.</p>
</li>
<li><p>Calculation of shape-factors between all triangular elements on the interior surfaces.</p>
</li>
</ul>
<p>In order to reduce the computational time required, the critical steps of the calculation process have been handled in the following manner.</p>
<p><strong>Surface subdivision</strong></p>
<p>The subdivision of the interior surfaces is carried out in almost the same manner as in the case of the subdivision of the windows. However, as the subdivision is very dependent on the location of the reference point, it is necessary to generate a new mesh on the interior surfaces every time the location of the reference point is changed, in order to obtain correct results. Every time a mesh is generated, it is necessary to re-compute the illumination on the interior surfaces. In the case of a multiple point calculation, the repeated mesh generation and re-computation of the illumination requires an excessive amount of computational time. It would therefore be convenient if as many of the triangular elements as possible could be used and reused in consecutive calculations. This has been achieved by implementing a dynamical mesh generation procedure.</p>
<p>When a mesh is generated, a "basic" mesh is initially generated. The idea of the basic mesh is that it should form the basis of all meshes used in consecutive calculations (i.e. in a multiple point calculation process). Therefore, the direct and externally reflected illuminations in all center-points of the triangular elements are calculated. Then, a finer mesh based on the location and orientation of the reference point is generated in the same way as described in Calculation of the direct illumination, except that the limits in the area - sphere relation are now 1/40, 1/64 and 1/88, for the three precision's respectively. The values are again experimentally determined. This finer mesh is generated such that the elements in the basic mesh form the basis of the generation of the finer mesh. Only in the case where the basic mesh elements do not satisfy the apparent area - sphere relation, is further subdivision carried out. The direct and externally reflected illuminations in all new elements are then calculated. In the case of a multiple-point calculation process, the finer mesh is deleted after each calculation for a reference point is completed. However, the basic mesh still exists and again forms the basis of further subdivisions, which depend on the location, and orientation of the new reference point. As a large part of the basic mesh is very often reusable, this approach saves much computational time. It may be argued that an easier approach would be to make the basic mesh sufficiently fine in the first place, thus eliminating the repeated elimination - regeneration processes. However, a sufficiently fine mesh must consist of very small elements if correct results for illumination at points close to a bounding surface are to be obtained. A large number of elements hugely diminishes the efficiency of the calculation, as will be obvious in the following two sections.</p>
<p>The basic mesh is initially generated on the basis of the volume of the space. The interior faces are subdivided until no triangular element has an area of more than 1/70, 1/90 and 1/110 m<sup>-1</sup> (for low, medium and high precision respectively) of the volume of the space it faces. The values are experimentally determined. The reason why the volume has been chosen, as the proportional factor is this: the inter-reflection between elements becomes more significant where the elements are "close" to one another. It is therefore desirable to have a finer mesh in, says a long, narrow room than in a cubic room. As the volume of a space indicates the geometry better than the total surface area does, it is chosen to use the volume rather than the total area of the interior surfaces as proportional factor for the limit on the element area. Other methods for the initial subdivisions will be tested in the future. A method, which in some way bases the limit on the element area on the distance between an element and its nearest edge, seems to be a better alternative.</p>
<p><strong>Calculation of initial illumination</strong></p>
<p>The calculation of the direct and externally reflected illumination falling upon the elements on the interior surfaces of the space is calculated in the same way as described in the section Calculation of the direct illumination. This step in the calculation process also reaps the benefits of the existence of the basic mesh in the case of multiple-point calculations. The illumination falling upon the elements in the basic mesh needs only to be calculated once. In succeeding calculations there is only need to calculate the initial illumination falling upon the elements in the finer mesh. This also reduces the required computational considerably.</p>
<p><strong>Shape-factor calculation</strong></p>
<p>There is basically two ways of performing a shape-factor calculation for a space:</p>
<ul>
<li><p>Divide the space surfaces in n sub-surfaces in which the illumination can be assumed constant. Perform integration over all pairs of sub-surfaces which "see" each other.</p>
</li>
<li><p>Divide the space surfaces in n sub-surfaces in which the illumination can be assumed constant. Use approximated formulas to estimate shape-factors between all pairs of sub-surfaces which "see" each other.</p>
</li>
</ul>
<p>The second approach is by far the fastest for obvious reasons. However, approximate formulas exist only for rectangular sub-surfaces, which cannot be used in cases where the surface itself is not rectangular. The approximate formula for the shape-factor between rectangular elements is:</p>
<p><span class="mathjax-block">\[
SF_{12} = \frac {\cos \theta_1 \cdot \cos \theta_2}{\pi r^2} A_2&nbsp;\tag{8}
\]</span></p>
<p>where<br></br>SF<sub>ij</sub> denotes the shape-factor of element j seen from element i,<br></br>θ<sub>i</sub> is the angle of incidence at element i,<br></br>r is the distance between the elements and<br></br>A<sub>i</sub> is the area of element i.</p>
<p>A possible solution could be to treat the triangular elements as rectangular elements during the shape-factor calculation provided that the assumption, that the change of the geometrical mass-distribution of the sub-surface is negligible, will hold. In the case where the sub-surfaces are "far" from each other, the approximation only gives rise to very small errors, but if relatively large sub-surfaces are "close" to each other, significant errors are observed.</p>
<p>The first approach, on the other hand, leads to correct results but is very time-consuming. Every shape-factor calculation is a calculation of a surface integral:</p>
<p><span class="mathjax-block">\[
A_{1}F_{12} =&nbsp;\int\limits_{A_1}&nbsp;\int\limits_{A_2} \frac {(dA_1 \cos \theta_1)(dA_2 \cos \theta_2)} {\pi r^2} \tag{9}
\]</span></p>
<p>where<br></br>A<sub>i</sub> is the area of surface i,<br></br>F<sub>ij</sub> is the shape-factor of element j seen from element i,<br></br><sub><span style="font-size: 14px;">θ</span>i</sub> is the angle of incidence at element i and<br></br>r is the distance between the elements.</p>
<p>In the case with n sub-surfaces on the boundaries of the space, the required number of shape-factor calculations is:</p>
<p><span class="mathjax-block">\[
n_{SF} = \frac{\sum_i n_i (n-n_i)}{2} = \frac{n^2 - \sum_{i} n_{i}^2}{2}&nbsp;\cong&nbsp;\frac{i-1}{2i} n^2 \tag{10}
\]</span></p>
<p>where<br></br>n<sub>i</sub> is the number of sub-surfaces on surface i,<br></br>n is the total number of sub-surfaces.</p>
<p>The division by 2 comes in to play as Area<sub>1</sub>SF<sub>12</sub>=Area<sub>2</sub>SF<sub>21</sub>.</p>
<p>The approximate equality sign expresses equality when all n<sub>i</sub> are equal.</p>
<p>Hence, the number of necessary calculations is proportional to n².</p>
<p>In SimLight, it has been chosen to use both methods such that the advantages of both methods can be reaped. The choice of which method to apply is set to depend on the areas of the triangular elements and the distance between these. If the ratio of the sum of the areas to the square of the distance between them exceeds 1, the approximate shape-factor formula is applied; otherwise an integral method is applied. The value 1 has been experimentally determined.</p>
<p>In SimLight, the Mitalas-Stephenson method is utilized for exact shape-factor calculation. This method is based on the line integral method, but with one of the integrals integrated analytically beforehand. The remaining integral, which is calculated numerically, is:</p>
<p><span class="mathjax-block">\[
A_{1}F_{12} = \frac{1}{2\pi} \sum_{p=1}^{n_1} \sum_{q=1}^{n_2} \Phi_{pq} \sum^{m_p} \left( (T \cos \varphi \ln T + S \cos \theta \ln S + U_\omega - R) \nu_i \right) _{p,q}&nbsp;\tag{11}
\]</span></p>
<p>where<br></br>S, T, U, φ, θ and ω are functions of the edge vector in the line integral.</p>
<p>The figure below illustrates the symbols in the equation. See (5) for further details.</p>
<p><img src="https://s3.amazonaws.com/outseta-production/10526/0-simlight-fig1_6766cc99-da9e-43ce-808c-e612930633ec.gif" alt="Illustration of symbols used in the Mitalas-Stephenson method."></img></p>
<p>Using this combination of calculation methods, correct shape-factors are calculated reasonably quickly.</p>
<p><strong>Interreflection calculation</strong></p>
<p>The inter-reflection calculation can be performed by solving n equations with n variables (implicitly or explicitly) or by finding the solution by means of an iterative method. As the matrix holding the shape-factors is almost a full matrix, an iterative method is likely to be more efficient than an equation solver as the Gauss elimination will require considerable computational time (proportional to n³). In SimLight, a simple Jacobi-iterative method is used.</p>
<p>The daylighting contribution from element i to element j is calculated as:</p>
<p><span class="mathjax-block">\[
dE_j = SF_{ji} \cdot E_i \cdot r_i \tag{12}
\]</span></p>
<p>where<br></br>dE<sub>j</sub> is the contribution to the illumination falling upon element j,<br></br>SF<sub>ji</sub> is the shape-factor of element i seen from element j,<br></br>E<sub>i</sub> is the illumination falling upon element i and<br></br>r<sub>i</sub> is the reflection coefficient of element i.</p>
<p>The reflection coefficient is taken from the finish of which element i is part. If the surface has no defined reflectance it is automatically set to the default.</p>
<p>The iteration procedure stops when the illumination falling upon any triangular element does not change by more than 5 % from one iteration to the next.</p>
<p>Finally, the contribution from all triangular sub-surfaces, visible from the reference point, to the illumination at the reference point is summed up in the same manner as described in the section <em>Calculation</em> <em>of the direct illumination</em>, with the luminance of sub-surface i calculated as:</p>
<p><span style="letter-spacing: -0.14px;"><span class="mathjax-block">\[
L_i = \frac{r_i \cdot E_i}{\pi}&nbsp;\tag{13}
\]</span></span></p>
<p>where<br></br>r<sub>i</sub> is the reflection coefficient of element i and<br></br>E<sub>i</sub> is the illumination falling upon sub-surface i.</p>
<p>The relation is given in (4).</p>
<h3 id="validation"><strong>Validation</strong></h3>
<p>The validation of the results obtained with SimLight consists of</p>
<ol>
<li>Comparison of calculated values for direct illumination with an analytical solution (formula given in (2)).   </li>
<li><p>Comparison of calculated values for direct and internally reflected illumination with results obtained with the application Prolight.<br></br>No recent and sophisticated software has been available for validation purposes during the development of the SimLight application. Therefore, the validation of the results sets certain limitations on which cases can be analyzed. The comparison with the analytical solution sets the restrictions that:</p>
</li>
<li><p>The sky must be of uniform luminance,</p>
</li>
<li><p>The reference plane must be perpendicular to the window plane,</p>
</li>
<li><p>The perpendicular at the reference point must be parallel to two of the edges of the rectangular window.</p>
</li>
</ol>
<p>The comparison with the <em>Prolight</em> software sets the restrictions that:</p>
<ul>
<li><p>The sky must be of uniform luminance,</p>
</li>
<li><p>The space must be box-shaped,</p>
</li>
<li><p>The reference plane must be vertically or horizontally oriented.</p>
</li>
</ul>
<p>Therefore, the results have not been validated in the general case with CIE-sky-models, irregularly shaped spaces and randomly oriented reference planes. However, tests with a gradual change of e.g. reference plane orientation have been carried out, and the results seem reasonable.</p>
<p>The details of the validation comparisons are not included in this paper. The general disagreement with the correct results obtained with the analytical solution appears not to exceed 4 %, 2 % and 1 % for calculations of low, medium and high precision respectively. The error is smaller the greater the distance of a bounding plane from the reference point. The general disagreement with the results obtained with the Prolight application does not seem to exceed 12 %, 5 % and 3 % for calculations of low, medium and high precision respectively. In general, the disagreement does not exceed 6 %, 3 % and 2 %, but the disagreement increases as the distance of a bounding plane to the reference point decreases. Neither a finer meshing nor a more accurate shape-factor calculation can eliminate this disagreement. Until the application has been tested against measurements or yet another application, it can not be ruled out that the results obtained with Prolight are in fact not completely accurate.</p>
<h3 id="default-material-properties"><strong>Default material properties</strong></h3>
<p>When no reflectance or light transmission is specified the following will be used:</p>
<p><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky">Building element</th>
<th class="tg-0pky"><span style="letter-spacing: -0.14px;">Reflectance</span></th>
<th class="tg-0pky"><span style="letter-spacing: -0.14px;">Light transmission</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky"><span style="letter-spacing: -0.14px;">Wall</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,40</span></td>
<td class="tg-0pky"> </td>
</tr>
<tr>
<td class="tg-0pky" style="text-align: left;"><span style="letter-spacing: -0.14px;">Roof</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,70</span></td>
<td class="tg-0pky"> </td>
</tr>
<tr>
<td class="tg-0pky"><span style="letter-spacing: -0.14px;">Floor</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,10</span></td>
<td class="tg-0pky"> </td>
</tr>
<tr>
<td class="tg-0pky"><span style="letter-spacing: -0.14px;">Ground</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,10</span></td>
<td class="tg-0pky"> </td>
</tr>
<tr>
<td class="tg-0pky"><span style="letter-spacing: -0.14px;">WinDoor</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,15</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,70</span></td>
</tr>
<tr>
<td class="tg-0pky"><span style="letter-spacing: -0.14px;">Overhang/sidefinn</span></td>
<td class="tg-0pky" style="text-align: center;"><span style="letter-spacing: -0.14px;">0,40</span></td>
<td class="tg-0pky"> </td>
</tr>
</tbody>
</table>



<h3 id="limitations"><strong>Limitations</strong></h3>
<p>There are a number of restrictions on the models that can be handled appropriately. It is required that the model complies with the following guide-lines:</p>
<ul>
<li><p>The room must be of convex nature.</p>
</li>
<li><p>The building must not have apertures connecting two rooms. These apertures will be treated as apertures to the outside.</p>
</li>
<li><p>Shading from outdoors obstructions is not considered. Only shading from fins is taken in to consideration.</p>
</li>
<li><p>Results are valid only for apertures with no glazing (no type) or clear, double glazing (any defined type).</p>
</li>
</ul>
<p>The following condition is given for all calculations:</p>
<ul>
<li>The windows are always assumed to be situated in the centerline of the construction it penetrates</li>
</ul>
<h3 id="references"><strong>References</strong></h3>
<ol>
<li><p>Christoffersen, J., Petersen, E. and Johnsen, K. Calculation Tools for Analysis of Daylighting in Buildings (in Danish), SBI-report 277, Statens Byggeforskningsinstitut, 1998.</p>
</li>
<li><p>Hopkinson, R.G., Petherbridge, P. and Longmore, J., Daylighting, Heinemann, 1964.</p>
</li>
<li><p>Mills, A.F., Heat Transfer, Irwin, 1993.</p>
</li>
<li><p>Ovesen, Ib, Concepts and Measurements, Light and Lighting (in Danish), Aschehoug,19??.</p>
</li>
<li><p>Walton, G.N., Algorithm for Calculating Radiation View Factors Between Plane Convex Polygons With Obstructions, National Bureau of Standards, Washington D.C., 1986.</p>
</li>
</ol>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../Diverse/test2.html" class="navigation navigation-prev " aria-label="Previous page: TEST3">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="test4.html" class="navigation navigation-next " aria-label="Next page: Test4">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Test3","level":"2.1","depth":1,"next":{"title":"Test4","level":"2.2","depth":1,"path":"Moduler/test4.md","ref":"Moduler/test4.md","articles":[]},"previous":{"title":"TEST3","level":"1.4.1.1","depth":3,"path":"Diverse/test2.md","ref":"Diverse/test2.md","articles":[]},"dir":"ltr"},"config":{"plugins":["remove-honkit-footer","language-picker@https://github.com/okalachev/gitbook-plugin-language-picker.git","mathjax-fix","head-append"],"styles":{"website":"styles.css"},"pluginsConfig":{"mathjax-fix":{},"language-picker":{"grid-columns":3},"livereload":{},"head-append":{"code":["<SCRIPTTAG>window.MathJax = { tex: { inlineMath: [[\\\"\\\\\\(\\\",\\\"\\\\\\)\\\"],[\\\"$\\\",\\\"$\\\"]], displayMath: [[\\\"\\\\\\[\\\",\\\"\\\\\\]\\\"],[\\\"$$\\\",\\\"$$\\\"]], packages: {'[+]': ['ams','textmacros']}, processEscapes: true }, options: { skipHtmlTags: [\\\"script\\\",\\\"noscript\\\",\\\"style\\\",\\\"textarea\\\",\\\"pre\\\",\\\"code\\\"] } };</SCRIPTTAG>","<SCRIPTTAG id=\"MathJax-script\" src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js\"></SCRIPTTAG>","<SCRIPTTAG>(function(){function cleanNBSP(root){var t=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);var n;while((n=t.nextNode())){if(n.nodeValue.indexOf('\\u00A0')!==-1){n.nodeValue=n.nodeValue.replace(/\\u00A0/g,' ');}}}function ts(){if(window.MathJax&&window.MathJax.typesetPromise){cleanNBSP(document.body);return window.MathJax.typesetPromise();}}function bind(){if(window.gitbook&&gitbook.events){gitbook.events.bind('page.change',ts);}document.addEventListener('DOMContentLoaded',ts);}if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',bind);}else{bind();}})();</SCRIPTTAG>","<SCRIPTTAG>document.addEventListener('DOMContentLoaded',function(){var l=document.createElement('link');l.rel='stylesheet';l.href=new URL('styles.css', document.baseURI).toString();document.head.appendChild(l);});</SCRIPTTAG>"]},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"remove-honkit-footer":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"da","gitbook":"*"},"file":{"path":"Moduler/test3.md","mtime":"2025-09-25T09:17:14.340Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-10-01T09:17:21.526Z"},"basePath":"..","book":{"language":"da"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-remove-honkit-footer/website.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-language-picker/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

